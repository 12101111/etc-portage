From f0dd04c2420d3724596d220272f7e76936d1ebba Mon Sep 17 00:00:00 2001
From: Nikita Popov <nikita.ppv@gmail.com>
Date: Mon, 22 Feb 2021 18:46:55 +0100
Subject: [PATCH] [MemCpyOpt] Fix handling of readnone byval arguments

If the call is readnone, then there may not be any MemoryAccess
associated with the call. Bail out in that case.

This fixes the issue reported at
https://reviews.llvm.org/D94376#2578312.

(cherry picked from commit 4125afc35723b490556f7a38f7835f0914f70292)
---
 llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp |  2 ++
 .../Transforms/MemCpyOpt/byval-readnone.ll     | 18 ++++++++++++++++++
 2 files changed, 20 insertions(+)
 create mode 100644 llvm/test/Transforms/MemCpyOpt/byval-readnone.ll

diff --git a/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp b/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
index a4e695497f30..d2d9140ef3eb 100644
--- a/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
+++ b/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
@@ -1541,6 +1541,8 @@ bool MemCpyOptPass::processByValArgument(CallBase &CB, unsigned ArgNo) {
   MemCpyInst *MDep = nullptr;
   if (EnableMemorySSA) {
     MemoryUseOrDef *CallAccess = MSSA->getMemoryAccess(&CB);
+    if (!CallAccess)
+      return false;
     MemoryAccess *Clobber = MSSA->getWalker()->getClobberingMemoryAccess(
         CallAccess->getDefiningAccess(), Loc);
     if (auto *MD = dyn_cast<MemoryDef>(Clobber))
diff --git a/llvm/test/Transforms/MemCpyOpt/byval-readnone.ll b/llvm/test/Transforms/MemCpyOpt/byval-readnone.ll
new file mode 100644
index 000000000000..cb62ff27f4be
--- /dev/null
+++ b/llvm/test/Transforms/MemCpyOpt/byval-readnone.ll
@@ -0,0 +1,18 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt < %s -memcpyopt -S -enable-memcpyopt-memoryssa=0 | FileCheck %s
+; RUN: opt < %s -memcpyopt -S -enable-memcpyopt-memoryssa=1 -verify-memoryssa | FileCheck %s
+
+%struct = type { i16 }
+
+declare i16 @g(%struct*) readnone
+
+define void @f() {
+; CHECK-LABEL: @f(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    [[CALL:%.*]] = call i16 @g(%struct* byval(%struct) align 1 undef)
+; CHECK-NEXT:    ret void
+;
+entry:
+  %call = call i16 @g(%struct* byval(%struct) align 1 undef)
+  ret void
+}
