From 99d975f679fc8d85c6b79f724703d06b28f4ade7 Mon Sep 17 00:00:00 2001
From: Nikita Popov <nikita.ppv@gmail.com>
Date: Sun, 22 Aug 2021 16:43:27 +0200
Subject: [PATCH 3/5] [InstCombine] Add tests for "eq of parts" with logical op
 (NFC)

We currently only handle this with a bitwise and/or instruction,
but not a logical.

(cherry picked from commit be4b8366fbd2c67b48a743d3e34837e29d6b8d0e)
---
 .../Transforms/InstCombine/eq-of-parts.ll     | 62 +++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/llvm/test/Transforms/InstCombine/eq-of-parts.ll b/llvm/test/Transforms/InstCombine/eq-of-parts.ll
index 3e7ac275e384..2b52e186e8a4 100644
--- a/llvm/test/Transforms/InstCombine/eq-of-parts.ll
+++ b/llvm/test/Transforms/InstCombine/eq-of-parts.ll
@@ -352,6 +352,37 @@ define i1 @eq_21_extra_use_eq2(i32 %x, i32 %y) {
   ret i1 %c.210
 }
 
+; Logical and instead of bitwise and.
+
+define i1 @eq_21_logical(i32 %x, i32 %y) {
+; CHECK-LABEL: @eq_21_logical(
+; CHECK-NEXT:    [[X_321:%.*]] = lshr i32 [[X:%.*]], 8
+; CHECK-NEXT:    [[X_1:%.*]] = trunc i32 [[X_321]] to i8
+; CHECK-NEXT:    [[X_32:%.*]] = lshr i32 [[X]], 16
+; CHECK-NEXT:    [[X_2:%.*]] = trunc i32 [[X_32]] to i8
+; CHECK-NEXT:    [[Y_321:%.*]] = lshr i32 [[Y:%.*]], 8
+; CHECK-NEXT:    [[Y_1:%.*]] = trunc i32 [[Y_321]] to i8
+; CHECK-NEXT:    [[Y_32:%.*]] = lshr i32 [[Y]], 16
+; CHECK-NEXT:    [[Y_2:%.*]] = trunc i32 [[Y_32]] to i8
+; CHECK-NEXT:    [[C_1:%.*]] = icmp eq i8 [[X_1]], [[Y_1]]
+; CHECK-NEXT:    [[C_2:%.*]] = icmp eq i8 [[X_2]], [[Y_2]]
+; CHECK-NEXT:    [[C_210:%.*]] = select i1 [[C_2]], i1 [[C_1]], i1 false
+; CHECK-NEXT:    ret i1 [[C_210]]
+;
+  %x.321 = lshr i32 %x, 8
+  %x.1 = trunc i32 %x.321 to i8
+  %x.32 = lshr i32 %x, 16
+  %x.2 = trunc i32 %x.32 to i8
+  %y.321 = lshr i32 %y, 8
+  %y.1 = trunc i32 %y.321 to i8
+  %y.32 = lshr i32 %y, 16
+  %y.2 = trunc i32 %y.32 to i8
+  %c.1 = icmp eq i8 %x.1, %y.1
+  %c.2 = icmp eq i8 %x.2, %y.2
+  %c.210 = select i1 %c.2, i1 %c.1, i1 false
+  ret i1 %c.210
+}
+
 ; Negative tests.
 
 define i1 @eq_21_wrong_op1(i32 %x, i32 %y, i32 %z) {
@@ -992,6 +1023,37 @@ define i1 @ne_21_extra_use_ne2(i32 %x, i32 %y) {
   ret i1 %c.210
 }
 
+; Logical or instead of bitwise or.
+
+define i1 @ne_21_logical(i32 %x, i32 %y) {
+; CHECK-LABEL: @ne_21_logical(
+; CHECK-NEXT:    [[X_321:%.*]] = lshr i32 [[X:%.*]], 8
+; CHECK-NEXT:    [[X_1:%.*]] = trunc i32 [[X_321]] to i8
+; CHECK-NEXT:    [[X_32:%.*]] = lshr i32 [[X]], 16
+; CHECK-NEXT:    [[X_2:%.*]] = trunc i32 [[X_32]] to i8
+; CHECK-NEXT:    [[Y_321:%.*]] = lshr i32 [[Y:%.*]], 8
+; CHECK-NEXT:    [[Y_1:%.*]] = trunc i32 [[Y_321]] to i8
+; CHECK-NEXT:    [[Y_32:%.*]] = lshr i32 [[Y]], 16
+; CHECK-NEXT:    [[Y_2:%.*]] = trunc i32 [[Y_32]] to i8
+; CHECK-NEXT:    [[C_1:%.*]] = icmp ne i8 [[X_1]], [[Y_1]]
+; CHECK-NEXT:    [[C_2:%.*]] = icmp ne i8 [[X_2]], [[Y_2]]
+; CHECK-NEXT:    [[C_210:%.*]] = select i1 [[C_2]], i1 true, i1 [[C_1]]
+; CHECK-NEXT:    ret i1 [[C_210]]
+;
+  %x.321 = lshr i32 %x, 8
+  %x.1 = trunc i32 %x.321 to i8
+  %x.32 = lshr i32 %x, 16
+  %x.2 = trunc i32 %x.32 to i8
+  %y.321 = lshr i32 %y, 8
+  %y.1 = trunc i32 %y.321 to i8
+  %y.32 = lshr i32 %y, 16
+  %y.2 = trunc i32 %y.32 to i8
+  %c.1 = icmp ne i8 %x.1, %y.1
+  %c.2 = icmp ne i8 %x.2, %y.2
+  %c.210 = select i1 %c.2, i1 true, i1 %c.1
+  ret i1 %c.210
+}
+
 ; Negative tests.
 
 define i1 @ne_21_wrong_op1(i32 %x, i32 %y, i32 %z) {
-- 
2.33.0

