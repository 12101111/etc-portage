diff --git a/src/Backends/SDLBackend.cpp b/src/Backends/SDLBackend.cpp
index 87bde7e..ec36239 100644
--- a/src/Backends/SDLBackend.cpp
+++ b/src/Backends/SDLBackend.cpp
@@ -1,6 +1,7 @@
 // For the nested case, reads input from the SDL window and send to wayland
 
 #include <X11/Xlib.h>
+#include <shared_mutex>
 #include <thread>
 #include <mutex>
 #include <string>
@@ -199,9 +200,12 @@ namespace gamescope
 
 		std::atomic<bool> m_bApplicationGrabbed = { false };
 		std::atomic<bool> m_bApplicationVisible = { false };
-		std::atomic<std::shared_ptr<INestedHints::CursorInfo>> m_pApplicationCursor;
-		std::atomic<std::shared_ptr<std::string>> m_pApplicationTitle;
-		std::atomic<std::shared_ptr<std::vector<uint32_t>>> m_pApplicationIcon;
+		std::shared_mutex m_pApplicationCursor_lock;
+		std::shared_ptr<INestedHints::CursorInfo> m_pApplicationCursor;
+		std::shared_mutex m_pApplicationTitle_lock;
+		std::shared_ptr<std::string> m_pApplicationTitle;
+		std::shared_mutex m_pApplicationIcon_lock;
+		std::shared_ptr<std::vector<uint32_t>> m_pApplicationIcon;
 		SDL_Surface *m_pIconSurface = nullptr;
 		SDL_Surface *m_pCursorSurface = nullptr;
 		SDL_Cursor *m_pCursor = nullptr;
@@ -523,6 +527,7 @@ namespace gamescope
 
 	void CSDLBackend::SetCursorImage( std::shared_ptr<INestedHints::CursorInfo> info )
 	{
+		std::unique_lock lock(m_pApplicationCursor_lock);
 		m_pApplicationCursor = info;
 		PushUserEvent( GAMESCOPE_SDL_EVENT_CURSOR );
 	}
@@ -538,11 +543,13 @@ namespace gamescope
 	}
 	void CSDLBackend::SetTitle( std::shared_ptr<std::string> szTitle )
 	{
+		std::unique_lock lock(m_pApplicationTitle_lock);
 		m_pApplicationTitle = szTitle;
 		PushUserEvent( GAMESCOPE_SDL_EVENT_TITLE );
 	}
 	void CSDLBackend::SetIcon( std::shared_ptr<std::vector<uint32_t>> uIconPixels )
 	{
+		std::unique_lock lock(m_pApplicationIcon_lock);
 		m_pApplicationIcon = uIconPixels;
 		PushUserEvent( GAMESCOPE_SDL_EVENT_ICON );
 	}
@@ -887,6 +894,7 @@ namespace gamescope
 					}
 					else if ( event.type == GetUserEventIndex( GAMESCOPE_SDL_EVENT_TITLE ) )
 					{
+						std::shared_lock lock(m_pApplicationTitle_lock);
 						std::shared_ptr<std::string> pAppTitle = m_pApplicationTitle;
 
 						std::string szTitle = pAppTitle ? *pAppTitle : "gamescope";
@@ -900,6 +908,7 @@ namespace gamescope
 					}
 					else if ( event.type == GetUserEventIndex( GAMESCOPE_SDL_EVENT_ICON ) )
 					{
+						std::shared_lock lock(m_pApplicationIcon_lock);
 						std::shared_ptr<std::vector<uint32_t>> pIcon = m_pApplicationIcon;
 
 						if ( m_pIconSurface )
@@ -928,6 +937,7 @@ namespace gamescope
 					}
 					else if ( event.type == GetUserEventIndex( GAMESCOPE_SDL_EVENT_CURSOR ) )
 					{
+						std::shared_lock lock(m_pApplicationCursor_lock);
 						std::shared_ptr<INestedHints::CursorInfo> pCursorInfo = m_pApplicationCursor;
 
 						if ( m_pCursorSurface )
diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index ab6d30c..32dedba 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -12,6 +12,8 @@
 #include "Utils/TempFiles.h"
 
 #include <cstring>
+#include <mutex>
+#include <shared_mutex>
 #include <unordered_map>
 #include <unordered_set>
 #include <csignal>
@@ -560,7 +562,8 @@ namespace gamescope
         std::optional<wl_fixed_t> m_ofPendingCursorX;
         std::optional<wl_fixed_t> m_ofPendingCursorY;
 
-        std::atomic<std::shared_ptr<zwp_relative_pointer_v1>> m_pRelativePointer = nullptr;
+        std::shared_mutex m_pRelativePointer_lock;
+        std::shared_ptr<zwp_relative_pointer_v1> m_pRelativePointer = nullptr;
         std::unordered_set<uint32_t> m_uScancodesHeld;
 
         void Wayland_Registry_Global( wl_registry *pRegistry, uint32_t uName, const char *pInterface, uint32_t uVersion );
@@ -2868,7 +2871,8 @@ namespace gamescope
 
     void CWaylandInputThread::SetRelativePointer( bool bRelative )
     {
-        if ( bRelative == !!m_pRelativePointer.load() )
+        std::unique_lock lock(m_pRelativePointer_lock);
+        if ( bRelative == !!m_pRelativePointer )
             return;
         // This constructors/destructors the display's mutex, so should be safe to do across threads.
         if ( !bRelative )
@@ -3057,7 +3061,8 @@ namespace gamescope
 		if ( !pPlane )
 			return;
 
-        if ( m_pRelativePointer.load() != nullptr )
+        std::shared_lock lock(m_pRelativePointer_lock);
+        if ( m_pRelativePointer != nullptr )
             return;
 
         if ( !cv_wayland_mouse_warp_without_keyboard_focus && !m_bKeyboardEntered )
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 4968397..f4d90ae 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -1040,7 +1040,8 @@ int g_BlurRadius = 5;
 unsigned int g_BlurFadeStartTime = 0;
 
 pid_t focusWindow_pid, sdFocusWindow_pid;
-std::atomic<std::shared_ptr<std::string>> focusWindow_engine = nullptr;
+std::shared_ptr<std::string> focusWindow_engine = nullptr;
+std::shared_mutex focusWindow_engine_lock;
 
 focus_t g_steamcompmgr_xdg_focus;
 std::vector<std::shared_ptr<steamcompmgr_win_t>> g_steamcompmgr_xdg_wins;
@@ -6694,7 +6695,7 @@ bool handle_done_commit( steamcompmgr_win_t *w, xwayland_ctx_t *ctx, uint64_t co
 					if ( !cv_paint_debug_pause_base_plane )
 						g_HeldCommits[ HELD_COMMIT_BASE ] = w->commit_queue[ j ];
 					hasRepaint = true;
-
+					std::unique_lock lock(focusWindow_engine_lock);
 					focusWindow_engine = w->engineName;
 					focusWindow_pid = w->pid;
 				}
diff --git a/src/steamcompmgr.hpp b/src/steamcompmgr.hpp
index 6734c15..a025595 100644
--- a/src/steamcompmgr.hpp
+++ b/src/steamcompmgr.hpp
@@ -1,5 +1,5 @@
 #include <stdint.h>
-
+#include <shared_mutex>
 #include "wlr_begin.hpp"
 #include <wlr/types/wlr_buffer.h>
 #include <wlr/render/wlr_texture.h>
@@ -144,7 +144,8 @@ struct wlserver_x11_surface_info *lookup_x11_surface_info_from_xid( gamescope_xw
 
 extern gamescope::VBlankTime g_SteamCompMgrVBlankTime;
 extern pid_t focusWindow_pid;
-extern std::atomic<std::shared_ptr<std::string>> focusWindow_engine;
+extern std::shared_mutex focusWindow_engine_lock;
+extern std::shared_ptr<std::string> focusWindow_engine;
 
 void init_xwayland_ctx(uint32_t serverId, gamescope_xwayland_server_t *xwayland_server);
 void gamescope_set_selection(std::string contents, GamescopeSelection eSelection);
