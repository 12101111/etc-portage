diff --git a/ell/useful.h b/ell/useful.h
index 4c8b23e..3b05595 100644
--- a/ell/useful.h
+++ b/ell/useful.h
@@ -62,8 +62,12 @@ static inline unsigned char bit_field(const unsigned char oct,
 #define __AUTODESTRUCT(func)				\
 	__attribute((cleanup(func ## _cleanup)))
 
-#define _auto_(func)					\
-	__AUTODESTRUCT(func)
+#define L_AUTO_CLEANUP_VAR(vartype,varname,destroy) \
+	vartype varname __attribute__((cleanup(destroy)))
+
+static inline void l_settings_cleanup(struct l_settings **ptr) {
+	l_settings_free(*ptr);
+}
 
 /*
  * Trick the compiler into thinking that var might be changed somehow by
diff --git a/src/ap.c b/src/ap.c
index 46a7a6a..7dbcbdb 100644
--- a/src/ap.c
+++ b/src/ap.c
@@ -3587,7 +3587,7 @@ static struct l_dbus_message *ap_dbus_start_profile(struct l_dbus *dbus,
 {
 	struct ap_if_data *ap_if = user_data;
 	const char *ssid;
-	_auto_(l_settings_free) struct l_settings *config = NULL;
+	L_AUTO_CLEANUP_VAR(struct l_settings *, config, l_settings_cleanup) = NULL;
 	char *config_path;
 	int err;
 
diff --git a/src/crypto.c b/src/crypto.c
index 3f51694..d5f5400 100644
--- a/src/crypto.c
+++ b/src/crypto.c
@@ -1139,6 +1139,14 @@ enum l_checksum_type crypto_sae_hash_from_ecc_prime_len(enum crypto_sae type,
 	return L_CHECKSUM_SHA512;
 }
 
+static void l_ecc_scalar_cleanup(struct l_ecc_scalar **ptr) {
+	l_ecc_scalar_free(*ptr);
+}
+
+static void l_ecc_point_cleanup(struct l_ecc_point **ptr) {
+	l_ecc_point_free(*ptr);
+}
+
 struct l_ecc_point *crypto_derive_sae_pt_ecc(unsigned int group,
 						const char *ssid,
 						const char *password,
@@ -1150,11 +1158,11 @@ struct l_ecc_point *crypto_derive_sae_pt_ecc(unsigned int group,
 	uint8_t pwd_seed[64]; /* SHA512 is the biggest possible right now */
 	uint8_t pwd_value[128];
 	size_t pwd_value_len;
-	_auto_(l_ecc_scalar_free) struct l_ecc_scalar *u1 = NULL;
-	_auto_(l_ecc_scalar_free) struct l_ecc_scalar *u2 = NULL;
-	_auto_(l_ecc_point_free) struct l_ecc_point *p1 = NULL;
-	_auto_(l_ecc_point_free) struct l_ecc_point *p2 = NULL;
-	_auto_(l_ecc_point_free) struct l_ecc_point *pt = NULL;
+	L_AUTO_CLEANUP_VAR(struct l_ecc_scalar *,u1,l_ecc_scalar_cleanup) = NULL;
+	L_AUTO_CLEANUP_VAR(struct l_ecc_scalar *,u2,l_ecc_scalar_cleanup) = NULL;
+	L_AUTO_CLEANUP_VAR(struct l_ecc_point *,p1,l_ecc_point_cleanup) = NULL;
+	L_AUTO_CLEANUP_VAR(struct l_ecc_point *,p2,l_ecc_point_cleanup) = NULL;
+	L_AUTO_CLEANUP_VAR(struct l_ecc_point *,pt,l_ecc_point_cleanup) = NULL;
 
 	if (!curve)
 		return NULL;
diff --git a/src/eap.c b/src/eap.c
index 0645be4..dd115b7 100644
--- a/src/eap.c
+++ b/src/eap.c
@@ -416,6 +416,8 @@ static const char *eap_type_to_str(enum eap_type type, uint32_t vendor_id,
 #define IS_EXPANDED_RESPONSE(id, t) \
 	(type == EAP_TYPE_EXPANDED && vendor_id == (id) && vendor_type == (t))
 
+#define response_is(wanted) type == wanted || IS_EXPANDED_RESPONSE(0, wanted)
+
 static void eap_handle_response(struct eap_state *eap, const uint8_t *pkt,
 				size_t len)
 {
@@ -428,14 +430,6 @@ static void eap_handle_response(struct eap_state *eap, const uint8_t *pkt,
 				eap->method->vendor_id[2];
 	uint32_t our_vendor_type = eap->method->vendor_type;
 
-	bool response_is(enum eap_type wanted)
-	{
-		if (type == wanted)
-			return true;
-
-		return IS_EXPANDED_RESPONSE(0, wanted);
-	}
-
 	if (len < 1)
 		/* Invalid packets to be ignored */
 		return;
diff --git a/src/missing.h b/src/missing.h
index a5b9295..a65800f 100644
--- a/src/missing.h
+++ b/src/missing.h
@@ -31,10 +31,7 @@ static inline void explicit_bzero(void *s, size_t n)
 #ifndef HAVE_RAWMEMCHR
 static inline void *rawmemchr(const void *s, int c)
 {
-_Pragma("GCC diagnostic push")
-_Pragma("GCC diagnostic ignored \"-Wstringop-overflow=\"")
 	return memchr(s, c, (size_t) -1);
-_Pragma("GCC diagnostic pop")
 }
 #endif
 
diff --git a/src/network.c b/src/network.c
index 9a2d12c..f1ece00 100644
--- a/src/network.c
+++ b/src/network.c
@@ -538,9 +538,9 @@ static int network_settings_load_pt_ecc(struct network *network,
 					unsigned int group,
 					struct l_ecc_point **out_pt)
 {
-	_auto_(l_free) char *key = l_strdup_printf(SAE_PT_SETTING, group);
+	L_AUTO_FREE_VAR(char *, key) = l_strdup_printf(SAE_PT_SETTING, group);
 	size_t pt_len;
-	_auto_(l_free) uint8_t *pt = l_settings_get_bytes(network->settings,
+	L_AUTO_FREE_VAR(uint8_t *, pt) = l_settings_get_bytes(network->settings,
 						"Security", key, &pt_len);
 	const struct l_ecc_curve *curve = l_ecc_curve_from_ike_group((group));
 
@@ -577,13 +577,13 @@ static int network_load_psk(struct network *network, bool need_passphrase)
 	const char *ssid = network_get_ssid(network);
 	enum security security = network_get_security(network);
 	size_t psk_len;
-	_auto_(l_free) uint8_t *psk =
+	L_AUTO_FREE_VAR(uint8_t *, psk) =
 			l_settings_get_bytes(network->settings, "Security",
 						"PreSharedKey", &psk_len);
-	_auto_(l_free) char *passphrase =
+	L_AUTO_FREE_VAR(char *, passphrase) =
 			l_settings_get_string(network->settings,
 						"Security", "Passphrase");
-	_auto_(l_free) char *path =
+	L_AUTO_FREE_VAR(char *, path) =
 		storage_get_network_file_path(security, ssid);
 
 	if (psk && psk_len != 32) {
@@ -626,7 +626,7 @@ static void network_settings_save_sae_pt_ecc(struct l_settings *settings,
 {
 	const struct l_ecc_curve *curve = l_ecc_point_get_curve(pt);
 	unsigned int group = l_ecc_curve_get_ike_group(curve);
-	_auto_(l_free) char *key = l_strdup_printf(SAE_PT_SETTING, group);
+	L_AUTO_FREE_VAR(char *, key) = l_strdup_printf(SAE_PT_SETTING, group);
 	uint8_t buf[256];
 	ssize_t len;
 
diff --git a/src/wsc.c b/src/wsc.c
index 2618497..78fb999 100644
--- a/src/wsc.c
+++ b/src/wsc.c
@@ -530,9 +530,9 @@ static void wsc_store_credentials(struct wsc_credentials_info *creds,
 	for (i = 0; i < n_creds; i++) {
 		enum security security = creds[i].security;
 		const char *ssid = creds[i].ssid;
-		_auto_(l_settings_free) struct l_settings *settings =
+		L_AUTO_CLEANUP_VAR(struct l_settings *, settings, l_settings_cleanup) =
 							l_settings_new();
-		_auto_(l_free) char *path =
+		L_AUTO_FREE_VAR(char *, path) =
 				storage_get_network_file_path(security, ssid);
 
 		if (l_settings_load_from_file(settings, path)) {
